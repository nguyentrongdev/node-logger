const express = require('express');
const cors = require('cors');
const fs = require('fs-extra');
const path = require('path');
const moment = require('moment');
const archiver = require('archiver');
const cron = require('node-cron');

const app = express();
const PORT = process.env.PORT || 4005;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Th∆∞ m·ª•c l∆∞u tr·ªØ logs
const LOGS_DIR = path.join(__dirname, 'logs');

// T·∫°o th∆∞ m·ª•c logs n·∫øu ch∆∞a t·ªìn t·∫°i
fs.ensureDirSync(LOGS_DIR);

// Utility function ƒë·ªÉ t·∫°o t√™n file theo ng√†y
const getLogFileName = (date) => {
  const dateStr = moment(date).format('YYYY-MM-DD');
  return `log-${dateStr}.txt`;
};

// Utility function ƒë·ªÉ t·∫°o ƒë∆∞·ªùng d·∫´n file log ƒë·∫ßy ƒë·ªß
const getLogFilePath = (date) => {
  const fileName = getLogFileName(date);
  return path.join(LOGS_DIR, fileName);
};

// Utility function ƒë·ªÉ t·∫°o timestamp theo format m·ªõi
const getFormattedTimestamp = () => {
  return moment().format('DD/MM/YYYY hh:mm:ss A');
};

// Utility function ƒë·ªÉ t·∫°o log entry theo format m·ªõi
const createLogEntry = (message, level = 'INFO', component = 'Application', platform = 'Nodejs') => {
  const timestamp = getFormattedTimestamp();
  return `[${platform}] - ${timestamp}    [${level}]  [${component}] ${message}\n`;
};

// Utility function ƒë·ªÉ cleanup logs c≈© h∆°n 2 tu·∫ßn
const cleanupOldLogs = async () => {
  try {
    console.log('üßπ Starting log cleanup process...');
    
    const files = await fs.readdir(LOGS_DIR);
    const logFiles = files.filter(file => file.startsWith('log-') && file.endsWith('.txt'));
    
    if (logFiles.length === 0) {
      console.log('üìù No log files found to cleanup');
      return { deleted: 0, kept: 0, errors: [] };
    }
    
    const twoWeeksAgo = moment().subtract(14, 'days');
    const results = {
      deleted: 0,
      kept: 0,
      errors: [],
      deletedFiles: [],
      keptFiles: []
    };
    
    for (const file of logFiles) {
      try {
        const dateMatch = file.match(/log-(\d{4}-\d{2}-\d{2})\.txt/);
        if (!dateMatch) {
          results.errors.push({ file, error: 'Invalid file format' });
          continue;
        }
        
        const fileDate = moment(dateMatch[1], 'YYYY-MM-DD');
        const filePath = path.join(LOGS_DIR, file);
        
        if (fileDate.isBefore(twoWeeksAgo)) {
          // X√≥a file c≈© h∆°n 2 tu·∫ßn
          await fs.unlink(filePath);
          results.deleted++;
          results.deletedFiles.push(file);
          console.log(`üóëÔ∏è  Deleted old log file: ${file} (${fileDate.format('YYYY-MM-DD')})`);
        } else {
          // Gi·ªØ l·∫°i file trong v√≤ng 2 tu·∫ßn
          results.kept++;
          results.keptFiles.push(file);
        }
      } catch (error) {
        console.error(`‚ùå Error processing file ${file}:`, error.message);
        results.errors.push({ file, error: error.message });
      }
    }
    
    console.log(`‚úÖ Cleanup completed: ${results.deleted} deleted, ${results.kept} kept, ${results.errors.length} errors`);
    
    // Log cleanup action
    const cleanupLogEntry = createLogEntry(
      `Log cleanup completed: ${results.deleted} files deleted, ${results.kept} files kept`,
      'INFO',
      'LogCleanup',
      'NodeLogger'
    );
    
    const today = moment().format('YYYY-MM-DD');
    const todayLogPath = getLogFilePath(today);
    await fs.appendFile(todayLogPath, cleanupLogEntry);
    
    return results;
    
  } catch (error) {
    console.error('‚ùå Error during log cleanup:', error);
    
    // Log error
    try {
      const errorLogEntry = createLogEntry(
        `Log cleanup failed: ${error.message}`,
        'ERROR',
        'LogCleanup',
        'NodeLogger'
      );
      
      const today = moment().format('YYYY-MM-DD');
      const todayLogPath = getLogFilePath(today);
      await fs.appendFile(todayLogPath, errorLogEntry);
    } catch (logError) {
      console.error('‚ùå Failed to log cleanup error:', logError);
    }
    
    throw error;
  }
};

// API 1: Ghi logger theo ng√†y
app.post('/api/log', async (req, res) => {
  try {
    const { message, date, level, component, platform } = req.body;
    
    if (!message) {
      return res.status(400).json({
        success: false,
        error: 'Message is required'
      });
    }

    // Validate log level n·∫øu ƒë∆∞·ª£c cung c·∫•p
    const validLevels = ['DEBUG', 'INFO', 'WARN', 'ERROR', 'FATAL'];
    const logLevel = level && validLevels.includes(level.toUpperCase()) 
      ? level.toUpperCase() 
      : 'INFO';

    // S·ª≠ d·ª•ng ng√†y hi·ªán t·∫°i n·∫øu kh√¥ng c√≥ ng√†y ƒë∆∞·ª£c cung c·∫•p
    const logDate = date || new Date();
    const logFilePath = getLogFilePath(logDate);
    
    // T·∫°o n·ªôi dung log v·ªõi format m·ªõi
    const timestamp = getFormattedTimestamp();
    const logEntry = createLogEntry(message, logLevel, component, platform);
    
    // Ghi v√†o file (append mode)
    await fs.appendFile(logFilePath, logEntry);
    
    res.json({
      success: true,
      message: 'Log ƒë√£ ƒë∆∞·ª£c ghi th√†nh c√¥ng',
      file: getLogFileName(logDate),
      timestamp: timestamp,
      level: logLevel,
      component: component || 'Application',
      platform: platform || 'Nodejs'
    });
    
  } catch (error) {
    console.error('Error writing log:', error);
    res.status(500).json({
      success: false,
      error: 'L·ªói khi ghi log'
    });
  }
});

// API 2: Ghi nhi·ªÅu logs c√πng m·ªôt l√∫c (batch)
app.post('/api/logs/batch', async (req, res) => {
  try {
    const { logs } = req.body;
    
    if (!logs || !Array.isArray(logs)) {
      return res.status(400).json({
        success: false,
        error: 'Logs must be an array'
      });
    }

    if (logs.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'Logs array cannot be empty'
      });
    }

    if (logs.length > 1000) {
      return res.status(400).json({
        success: false,
        error: 'Maximum 1000 logs per batch allowed'
      });
    }

    const results = {
      total: logs.length,
      successful: 0,
      failed: 0,
      errors: [],
      files_written: new Set()
    };

    const validLevels = ['DEBUG', 'INFO', 'WARN', 'ERROR', 'FATAL'];

    // Group logs by date ƒë·ªÉ optimize file writes
    const logsByDate = new Map();

    // Validate v√† group logs
    for (let i = 0; i < logs.length; i++) {
      const log = logs[i];
      
      if (!log.message) {
        results.failed++;
        results.errors.push({
          index: i,
          error: 'Message is required',
          log: log
        });
        continue;
      }

      // Validate v√† set defaults
      const logLevel = log.level && validLevels.includes(log.level.toUpperCase()) 
        ? log.level.toUpperCase() 
        : 'INFO';
      
      const logDate = log.date || new Date();
      const component = log.component || 'Application';
      const platform = log.platform || 'Nodejs';
      
      const logEntry = createLogEntry(log.message, logLevel, component, platform);
      const dateKey = moment(logDate).format('YYYY-MM-DD');
      
      if (!logsByDate.has(dateKey)) {
        logsByDate.set(dateKey, []);
      }
      
      logsByDate.get(dateKey).push({
        index: i,
        entry: logEntry,
        level: logLevel,
        component: component,
        platform: platform
      });
    }

    // Ghi logs theo t·ª´ng ng√†y
    for (const [dateKey, dayLogs] of logsByDate) {
      try {
        const logFilePath = getLogFilePath(dateKey);
        const logContent = dayLogs.map(log => log.entry).join('');
        
        await fs.appendFile(logFilePath, logContent);
        
        results.successful += dayLogs.length;
        results.files_written.add(getLogFileName(dateKey));
        
      } catch (error) {
        // N·∫øu ghi file th·∫•t b·∫°i, mark t·∫•t c·∫£ logs c·ªßa ng√†y ƒë√≥ l√† failed
        dayLogs.forEach(log => {
          results.failed++;
          results.errors.push({
            index: log.index,
            error: `Failed to write to file: ${error.message}`,
            date: dateKey
          });
        });
      }
    }

    // Adjust successful count if there were file write errors
    results.successful = results.total - results.failed;

    const response = {
      success: results.failed === 0,
      message: `Batch log completed: ${results.successful}/${results.total} logs written successfully`,
      results: {
        total: results.total,
        successful: results.successful,
        failed: results.failed,
        files_written: Array.from(results.files_written),
        timestamp: getFormattedTimestamp()
      }
    };

    // Include errors if any failed
    if (results.failed > 0) {
      response.results.errors = results.errors;
    }

    res.status(results.failed === 0 ? 200 : 207).json(response); // 207 = Multi-Status
    
  } catch (error) {
    console.error('Error in batch log:', error);
    res.status(500).json({
      success: false,
      error: 'L·ªói khi ghi batch logs'
    });
  }
});

// API 3: T·∫£i file logger theo ng√†y
app.get('/api/log/download/:date', async (req, res) => {
  try {
    const { date } = req.params;
    
    // Validate date format
    if (!moment(date, 'YYYY-MM-DD', true).isValid()) {
      return res.status(400).json({
        success: false,
        error: 'Invalid date format. Use YYYY-MM-DD'
      });
    }
    
    const logFilePath = getLogFilePath(date);
    
    // Ki·ªÉm tra file c√≥ t·ªìn t·∫°i kh√¥ng
    if (!await fs.pathExists(logFilePath)) {
      return res.status(404).json({
        success: false,
        error: `Kh√¥ng t√¨m th·∫•y file log cho ng√†y ${date}`
      });
    }
    
    const fileName = getLogFileName(date);
    
    // Thi·∫øt l·∫≠p headers ƒë·ªÉ t·∫£i file
    res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
    res.setHeader('Content-Type', 'text/plain');
    
    // G·ª≠i file
    res.sendFile(logFilePath);
    
  } catch (error) {
    console.error('Error downloading log:', error);
    res.status(500).json({
      success: false,
      error: 'L·ªói khi t·∫£i file log'
    });
  }
});

// API 4: Xem n·ªôi dung file logger theo ng√†y (optional)
app.get('/api/log/:date', async (req, res) => {
  try {
    const { date } = req.params;
    
    // Validate date format
    if (!moment(date, 'YYYY-MM-DD', true).isValid()) {
      return res.status(400).json({
        success: false,
        error: 'Invalid date format. Use YYYY-MM-DD'
      });
    }
    
    const logFilePath = getLogFilePath(date);
    
    // Ki·ªÉm tra file c√≥ t·ªìn t·∫°i kh√¥ng
    if (!await fs.pathExists(logFilePath)) {
      return res.status(404).json({
        success: false,
        error: `Kh√¥ng t√¨m th·∫•y file log cho ng√†y ${date}`
      });
    }
    
    // ƒê·ªçc n·ªôi dung file
    const fileContent = await fs.readFile(logFilePath, 'utf8');
    
    // Chuy·ªÉn content th√†nh array, lo·∫°i b·ªè d√≤ng tr·ªëng
    const contentArray = fileContent
      .split('\n')
      .filter(line => line.trim() !== '');
    
    res.json({
      success: true,
      date: date,
      file: getLogFileName(date),
      content: contentArray,
      total_lines: contentArray.length
    });
    
  } catch (error) {
    console.error('Error reading log:', error);
    res.status(500).json({
      success: false,
      error: 'L·ªói khi ƒë·ªçc file log'
    });
  }
});

// API 5: L·∫•y danh s√°ch c√°c file log c√≥ s·∫µn
app.get('/api/logs', async (req, res) => {
  try {
    const files = await fs.readdir(LOGS_DIR);
    const logFiles = files
      .filter(file => file.startsWith('log-') && file.endsWith('.txt'))
      .map(file => {
        const dateMatch = file.match(/log-(\d{4}-\d{2}-\d{2})\.txt/);
        return {
          filename: file,
          date: dateMatch ? dateMatch[1] : null,
          path: `/api/log/${dateMatch ? dateMatch[1] : ''}`
        };
      })
      .filter(item => item.date)
      .sort((a, b) => b.date.localeCompare(a.date)); // S·∫Øp x·∫øp theo ng√†y gi·∫£m d·∫ßn
    
    res.json({
      success: true,
      logs: logFiles
    });
    
  } catch (error) {
    console.error('Error listing logs:', error);
    res.status(500).json({
      success: false,
      error: 'L·ªói khi l·∫•y danh s√°ch log'
    });
  }
});

// API 6: T·∫£i t·∫•t c·∫£ file logs d∆∞·ªõi d·∫°ng ZIP
app.get('/api/logs/download-all', async (req, res) => {
  try {
    const files = await fs.readdir(LOGS_DIR);
    const logFiles = files.filter(file => file.startsWith('log-') && file.endsWith('.txt'));
    
    if (logFiles.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Kh√¥ng c√≥ file log n√†o ƒë·ªÉ t·∫£i'
      });
    }
    
    // T·∫°o t√™n file zip v·ªõi timestamp
    const timestamp = moment().format('YYYY-MM-DD_HH-mm-ss');
    const zipFileName = `all-logs_${timestamp}.zip`;
    
    // Thi·∫øt l·∫≠p headers
    res.setHeader('Content-Type', 'application/zip');
    res.setHeader('Content-Disposition', `attachment; filename="${zipFileName}"`);
    
    // T·∫°o archive
    const archive = archiver('zip', {
      zlib: { level: 9 } // Compression level
    });
    
    // Pipe archive data to response
    archive.pipe(res);
    
    // X·ª≠ l√Ω l·ªói
    archive.on('error', (err) => {
      console.error('Archive error:', err);
      if (!res.headersSent) {
        res.status(500).json({
          success: false,
          error: 'L·ªói khi t·∫°o file ZIP'
        });
      }
    });
    
    // Th√™m c√°c file log v√†o archive
    for (const file of logFiles) {
      const filePath = path.join(LOGS_DIR, file);
      if (await fs.pathExists(filePath)) {
        archive.file(filePath, { name: file });
      }
    }
    
    // Th√™m file th√¥ng tin t·ªïng h·ª£p
    const summary = {
      generated_at: moment().format('YYYY-MM-DD HH:mm:ss'),
      total_files: logFiles.length,
      files: logFiles.map(file => {
        const dateMatch = file.match(/log-(\d{4}-\d{2}-\d{2})\.txt/);
        return {
          filename: file,
          date: dateMatch ? dateMatch[1] : null
        };
      }).filter(item => item.date).sort((a, b) => a.date.localeCompare(b.date))
    };
    
    archive.append(JSON.stringify(summary, null, 2), { name: 'logs-summary.json' });
    
    // Finalize archive
    await archive.finalize();
    
  } catch (error) {
    console.error('Error downloading all logs:', error);
    if (!res.headersSent) {
      res.status(500).json({
        success: false,
        error: 'L·ªói khi t·∫£i t·∫•t c·∫£ file log'
      });
    }
  }
});

// API 7: Manual cleanup logs c≈© h∆°n 2 tu·∫ßn
app.post('/api/logs/cleanup', async (req, res) => {
  try {
    console.log('üßπ Manual cleanup triggered via API');
    
    const results = await cleanupOldLogs();
    
    res.json({
      success: true,
      message: 'Log cleanup completed successfully',
      results: {
        deleted: results.deleted,
        kept: results.kept,
        errors: results.errors.length,
        deleted_files: results.deletedFiles,
        kept_files: results.keptFiles,
        timestamp: getFormattedTimestamp()
      }
    });
    
  } catch (error) {
    console.error('Error in manual cleanup:', error);
    res.status(500).json({
      success: false,
      error: 'L·ªói khi th·ª±c hi·ªán cleanup logs',
      message: error.message
    });
  }
});

// API 8: X√≥a file log theo ng√†y
app.delete('/api/log/:date', async (req, res) => {
  try {
    const { date } = req.params;
    
    // Validate date format
    if (!moment(date, 'YYYY-MM-DD', true).isValid()) {
      return res.status(400).json({
        success: false,
        error: 'Invalid date format. Use YYYY-MM-DD'
      });
    }
    
    const logFilePath = getLogFilePath(date);
    const fileName = getLogFileName(date);
    
    // Ki·ªÉm tra file c√≥ t·ªìn t·∫°i kh√¥ng
    if (!await fs.pathExists(logFilePath)) {
      return res.status(404).json({
        success: false,
        error: `Kh√¥ng t√¨m th·∫•y file log cho ng√†y ${date}`
      });
    }
    
    // X√≥a file log
    await fs.unlink(logFilePath);
    
    console.log(`üóëÔ∏è Log file deleted: ${fileName} for date ${date}`);
    
    // Log action v√†o file h√¥m nay (n·∫øu kh√¥ng ph·∫£i file h√¥m nay b·ªã x√≥a)
    const today = moment().format('YYYY-MM-DD');
    if (date !== today) {
      try {
        const deleteLogEntry = createLogEntry(
          `Log file deleted: ${fileName} (${date})`,
          'INFO',
          'LogDelete',
          'NodeLogger'
        );
        
        const todayLogPath = getLogFilePath(today);
        await fs.appendFile(todayLogPath, deleteLogEntry);
      } catch (logError) {
        console.error('‚ùå Failed to log delete action:', logError);
        // Kh√¥ng throw error v√¨ vi·ªác x√≥a file ƒë√£ th√†nh c√¥ng
      }
    }
    
    res.json({
      success: true,
      message: `File log cho ng√†y ${date} ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng`,
      deleted_file: fileName,
      date: date,
      timestamp: getFormattedTimestamp()
    });
    
  } catch (error) {
    console.error('Error deleting log:', error);
    res.status(500).json({
      success: false,
      error: 'L·ªói khi x√≥a file log',
      message: error.message
    });
  }
});

// Route g·ªëc
app.get('/', (req, res) => {
  res.json({
    message: 'Node Logger Server',
    apis: [
      {
        method: 'POST',
        path: '/api/log',
        description: 'Ghi log m·ªõi',
        body: {
          message: 'string (required)',
          date: 'string (optional, YYYY-MM-DD format)',
          level: 'string (optional, DEBUG|INFO|WARN|ERROR|FATAL, default: INFO)',
          component: 'string (optional, default: Application)',
          platform: 'string (optional, default: Nodejs)'
        }
      },
      {
        method: 'POST',
        path: '/api/logs/batch',
        description: 'Ghi nhi·ªÅu logs c√πng m·ªôt l√∫c (t·ªëi ƒëa 1000 logs)',
        body: {
          logs: 'array (required) - M·∫£ng c√°c log objects v·ªõi c√πng structure nh∆∞ /api/log (bao g·ªìm platform)'
        }
      },
      {
        method: 'GET',
        path: '/api/log/download/:date',
        description: 'T·∫£i file log theo ng√†y',
        params: {
          date: 'string (YYYY-MM-DD format)'
        }
      },
      {
        method: 'GET',
        path: '/api/log/:date',
        description: 'Xem n·ªôi dung log theo ng√†y',
        params: {
          date: 'string (YYYY-MM-DD format)'
        }
      },
      {
        method: 'GET',
        path: '/api/logs',
        description: 'L·∫•y danh s√°ch t·∫•t c·∫£ c√°c file log'
      },
      {
        method: 'GET',
        path: '/api/logs/download-all',
        description: 'T·∫£i t·∫•t c·∫£ file logs d∆∞·ªõi d·∫°ng ZIP'
      },
      {
        method: 'POST',
        path: '/api/logs/cleanup',
        description: 'Manual cleanup logs c≈© h∆°n 2 tu·∫ßn'
      },
      {
        method: 'DELETE',
        path: '/api/log/:date',
        description: 'X√≥a file log theo ng√†y',
        params: {
          date: 'string (YYYY-MM-DD format)'
        }
      }
    ]
  });
});

// Cron job: Cleanup logs c≈© h∆°n 2 tu·∫ßn m·ªói ng√†y l√∫c 2:00 AM
cron.schedule('0 2 * * *', async () => {
  console.log('‚è∞ Scheduled log cleanup started at', new Date().toISOString());
  try {
    await cleanupOldLogs();
    console.log('‚úÖ Scheduled log cleanup completed successfully');
  } catch (error) {
    console.error('‚ùå Scheduled log cleanup failed:', error.message);
  }
}, {
  scheduled: true,
  timezone: "Asia/Ho_Chi_Minh"
});

console.log('üìÖ Cron job scheduled: Daily log cleanup at 2:00 AM (Asia/Ho_Chi_Minh)');

// Run initial cleanup on server start (optional)
setTimeout(async () => {
  console.log('üöÄ Running initial log cleanup on server start...');
  try {
    await cleanupOldLogs();
    console.log('‚úÖ Initial log cleanup completed');
  } catch (error) {
    console.error('‚ùå Initial log cleanup failed:', error.message);
  }
}, 5000); // Delay 5 seconds after server start

// Start server
app.listen(PORT, () => {
  console.log(`üöÄ Server ƒëang ch·∫°y t·∫°i http://localhost:${PORT}`);
  console.log(`üìÅ Th∆∞ m·ª•c logs: ${LOGS_DIR}`);
});

module.exports = app;
